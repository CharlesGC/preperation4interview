<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        // ----↓---------------------↓------------------↓------------------↓--------------------------↓---------------------------
        // symmetric(lastRight对称点) j(i对称点)     lastMiddle              i                       lastRight
        // lastRight<=i, =>没有计算过点数据可以复用，乖乖从半径1开始一个一个计算是否对称
        // lastRight>i 分两种情况，但是 j= 2*lastMiddle-i
        // 1. lastRight-i > radiusArr[j] => radiusArr[j]回文已经对比过，lastMiddle是[j,i]和[symmetric, lastRight]中点，所以radiusArr[i]的最小初始半径应该是radiusArr[j]
        // 2. lastRight-i <= radiusArr[j] => lastRight-i回文已经对比过，lastMiddle是[j,i]和[symmetric, lastRight]中点，，所以radiusArr[i]的最小初始半径应该是lastRight-i
        // 综上所述， radiusArr[i] = lastRight>i ? Math.min(radiusArr[2*lastMiddle-i],lastRight-i) : 1

        // 使用拉马车算法，Manacher算法，马拉车算法
        function longestpalindrome(str){

            let formatStr = "$#" + str.split("").join("#")+"#";
            let radiusArr = Array.from({length: formatStr.length},()=>{return 0;});

            // console.log(formatStr,radiusArr);

            //lastMiddle为上一个中心点的位置，lastRight为上一个最右端的点的位置
            let lastMiddle=0,lastRight=0 
            //maxRadius为最大回文串的半径，maxMiddle为最大回文字符中心点的位置
            let maxRadius=0, maxMiddle=0;    
            // 从第二个字符开始以i作为移动的中心点的位置
            for (let i = 1; i < formatStr.length; ++i) {
              // lastRight<=i, =>没有计算过点数据可以复用，乖乖从半径1开始一个一个计算是否对称
              // lastRight>i 分两种情况，但是 j= 2*lastMiddle-i
              // 1. lastRight-i > radiusArr[j] => radiusArr[j]回文已经对比过，lastMiddle是[j,i]和[symmetric, lastRight]中点，所以radiusArr[i]的最小初始半径应该是radiusArr[j]
              // 2. lastRight-i <= radiusArr[j] => lastRight-i回文已经对比过，lastMiddle是[j,i]和[symmetric, lastRight]中点，，所以radiusArr[i]的最小初始半径应该是lastRight-i
              // 综上所述， radiusArr[i] = lastRight>i ? Math.min(radiusArr[2*lastMiddle-i],lastRight-i) : 1
              radiusArr[i] = lastRight > i ? Math.min(radiusArr[2 * lastMiddle - i], lastRight - i) : 1;
              // i是移动的中心点，p中存储的是以索引i为中心点的半径数组，只要对称则半径加1
              while (formatStr[i + radiusArr[i]] === formatStr[i - radiusArr[i]]) ++radiusArr[i]; 
              // 输出所有的对称回文子串
              let tempSub = str.substr(((i - radiusArr[i]) / 2), radiusArr[i]-1);
              console.log(tempSub ? tempSub : "empty");
              if (lastRight < i + radiusArr[i]) {
                  lastRight = i + radiusArr[i];
                  lastMiddle = i;
              }
              if (maxRadius < radiusArr[i]) {
                  maxRadius = radiusArr[i];
                  maxMiddle = i;
              }
            }

            // console.log(formatStr.substring((maxMiddle-maxRadius+1), (maxMiddle+maxRadius-1)));
            // 开始位置：索引从零开始加了$符抵消了，所以不用-1了（中点-半径除于2即可），截取长度等于半径-1，因为半径都是加过1的。
            return str.substr(((maxMiddle - maxRadius) / 2), maxRadius-1);
        }

        // console.log(longestpalindrome("a"));
        // console.log(longestpalindrome("aab"));
        // console.log(longestpalindrome("abcde"));
        // console.log(longestpalindrome("zzbaabcd"));
        // console.log(longestpalindrome(""));
        // console.log(longestpalindrome("abbaz"));
        // console.log(longestpalindrome("i like racecars that go fast"));
        // console.log(longestpalindrome("i am baab mbcd"));

        // let fn = (a,b)=>{
        //     return a+b;
        // }
        // let res = fn.call(1,2);
        // res;

        let p1 = ()=>{
            return new Promise((resolve,reject)=>{
                setTimeout(function(){
                    console.log("p1");     
                    resolve();           
                },2000);
            });
        };

        let p2 = ()=>{
            return new Promise((resolve,reject)=>{
                setTimeout(function(){
                    console.log("p2");     
                    resolve();           
                },2000);
            });
        };
        
        // let p3= new Promise((resolve,reject)=>{
        //         setTimeout(function(){
        //             console.log("p3");     
        //             resolve();           
        //         },2000);
        //     });
        //     let p4= new Promise((resolve,reject)=>{
        //         setTimeout(function(){
        //             console.log("p4");     
        //             resolve();           
        //         },2000);
        //     });


        //  异步promise同步按顺序执行
        // function runPromiseByQueue(myPromises) {
        //     myPromises.reduce(
        //         (previousPromise, nextPromise) => previousPromise.then(() => nextPromise()),
        //         Promise.resolve()
        //     );
        // }

        // const createPromise = (time, id) => () =>
        //     new Promise(solve =>
        //         setTimeout(() => {
        //         console.log("promise", id);
        //         solve();
        //         }, time)
        //     );

        // runPromiseByQueue([
        //     createPromise(3000, 1),
        //     createPromise(2000, 2),
        //     createPromise(1000, 3)
        // ]);
        // runPromiseByQueue([p1, p2]);
        
        // [p1, p2].reduce((total, currentVal)=>{
        //     total.then(currentVal);
        // });

        class test{
            constructor(name){
                // this.name = name;
            }
            static sMethod(){
                console.log("smethod");
                
            }
            sayName(){
                console.log(this.name);                
            }
        }

        // for (const key in test) {
        //     if (test.hasOwnProperty(key)) {
        //         const element = test[key];
        //         console.log(element);
        //     }
        // }
        // console.log("-----")
        // // 不可枚举属性也可以遍历出来
        // Reflect.ownKeys(test).map((val, index)=>{
        //     console.log(val);
            
        // });

        /*
          给两个版本号 a 和 b ，用逗号和一个空格分隔开，判断大小。假设两个版本的版本段是一致的.

          a<b 输出 -1
          a=b 输出 0
          a>b 输出 1
          样例输入
          1.10.2, 1.2.10
          样例输出
          1
        */
        function compareVersion(str){
          const versions = str.split(", ");
          const [v1,v2] = versions;
          function getAllVersion(version){
            return version.split(".");
          };
          const v1Versions = getAllVersion(v1);
          const v2Versions = getAllVersion(v2);
          // 两个版本段一致，所有数组长度相等
          for (let index = 0; index < v1Versions.length; index++) {
            const v1Version = v1Versions[index];
            const v2Version = v2Versions[index];
            if(v1Version>v2Version){
              return 1;
            } else if(v2Version<v1Version){
              return -1;
            }
          }
          return 0;
        }
        console.log(compareVersion("1.10.2, 1.2.10"));

        /*
          输入一个有序 int 数组，去重规则：数字 x 的出现次数不超过 x，问去重后数组的最大长度
          样例输入
          1 1 1 2 2 2 3 3 3
          样例输出
          6
        */
        function getRepeatArrMaxLen(arr){
          let len=0;
          let maxLen = 0;
          let lastNum;
          for (let index = 0; index < arr.length; index++) {
            const currentNum = arr[index];
            if(lastNum === currentNum){
              if(++len<currentNum){
                maxLen++;
              }
            } else{
              len=0;
              lastNum = currentNum;
              maxLen++;
            }
          }
          return maxLen;
        }

        console.log(getRepeatArrMaxLen([1, 1, 1, 2, 2, 2, 3, 3, 3,4,4]));

        /*
          经典动态规划题，给定 m 和 n 表示矩阵的长宽，小明从左上角走到右下角一共有多少条路，只等向右走或者向下走。注意数字溢出问题。 m n 的值都不超过 50.
          样例输入
          3 2
          样例输出
          3
        */
        // function getWays(m,n){
        //   if(m===1 || n===1){
        //     // 终止条件
        //     return 1;
        //   } else{
        //     // 子方程
        //     return getWays(m-1,n)+getWays(m,n-1);
        //   }          
        // }
        function getWays(m,n){
          let matrix = [];
          let line = Array.from({length:n},(val,index)=>1);
          
          for (let col = 0; col < m; col++) {
            matrix.push(line);           
          }
          
          for (let i = 1; i < m; i++) {
            for (let j = 1; j < n; j++) {
              matrix[i][j] = matrix[i-1][j] + matrix[i][j-1];
            }         
          }          
          return matrix[m-1][n-1];
        }

        console.log(getWays(3,2))


    </script>
</body>
</html>