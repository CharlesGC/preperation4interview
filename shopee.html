<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        function longestpalindrome(str){
            let t = "$#" + str.split("").join("#")+"#";
            let p = Array.from({length: t.length},()=>{return 0;});

            // console.log(t,p);

            //lastMiddle为上一个中心点，lastRight为上一个最右端的点
            let lastMiddle=0,lastRight=0 
            //maxRadius为最大回文串的半径，maxMiddle为最大回文字符中心点
            let maxRadius=0, maxMiddle=0;    
            // 从第二个字符开始以i作为移动的中心点
            for (let i = 1; i < t.length; ++i) {
                p[i] = lastRight > i ? Math.min(p[2 * lastMiddle - i], lastRight - i) : 1;
                // i是移动的中心点，p中存储的是以索引i为中心点的半径数组，只要对称则半径加1
                while (t[i + p[i]] === t[i - p[i]]) ++p[i]; 
                if (lastRight < i + p[i]) {
                    lastRight = i + p[i];
                    lastMiddle = i;
                }
                if (maxRadius < p[i]) {
                    maxRadius = p[i];
                    maxMiddle = i;
                }
            }

            // console.log(t.substring((maxMiddle-maxRadius+1), (maxMiddle+maxRadius-1)));
            // 开始位置：索引从零开始加了$符抵消了，所以不用-1了（中点-半径除于2即可），截取长度等于半径-1，因为半径都是加过1的。
            return str.substr(((maxMiddle - maxRadius) / 2), maxRadius-1);
        }

        console.log(longestpalindrome("a"));
        console.log(longestpalindrome("aab"));
        console.log(longestpalindrome("abcde"));
        console.log(longestpalindrome("zzbaabcd"));
        console.log(longestpalindrome(""));
        console.log(longestpalindrome("abbaz"));
        console.log(longestpalindrome("i like racecars that go fast"));
        console.log(longestpalindrome("i am baab mbcd"));

        // let fn = (a,b)=>{
        //     return a+b;
        // }
        // let res = fn.call(1,2);
        // res;

        let p1 = ()=>{
            return new Promise((resolve,reject)=>{
                setTimeout(function(){
                    console.log("p1");     
                    resolve();           
                },2000);
            });
        };

        let p2 = ()=>{
            return new Promise((resolve,reject)=>{
                setTimeout(function(){
                    console.log("p2");     
                    resolve();           
                },2000);
            });
        };
        
        // let p3= new Promise((resolve,reject)=>{
        //         setTimeout(function(){
        //             console.log("p3");     
        //             resolve();           
        //         },2000);
        //     });
        //     let p4= new Promise((resolve,reject)=>{
        //         setTimeout(function(){
        //             console.log("p4");     
        //             resolve();           
        //         },2000);
        //     });


        // function runPromiseByQueue(myPromises) {
        //     myPromises.reduce(
        //         (previousPromise, nextPromise) => previousPromise.then(() => nextPromise()),
        //         Promise.resolve()
        //     );
        // }

        // const createPromise = (time, id) => () =>
        //     new Promise(solve =>
        //         setTimeout(() => {
        //         console.log("promise", id);
        //         solve();
        //         }, time)
        //     );

        // runPromiseByQueue([
        //     createPromise(3000, 1),
        //     createPromise(2000, 2),
        //     createPromise(1000, 3)
        // ]);
        // runPromiseByQueue([p1, p2]);
        
        // [p1, p2].reduce((total, currentVal)=>{
        //     total.then(currentVal);
        // });

        class test{
            constructor(name){
                // this.name = name;
            }
            static sMethod(){
                console.log("smethod");
                
            }
            sayName(){
                console.log(this.name);                
            }
        }

        // for (const key in test) {
        //     if (test.hasOwnProperty(key)) {
        //         const element = test[key];
        //         console.log(element);
        //     }
        // }
        // console.log("-----")
        // // 不可枚举属性也可以遍历出来
        // Reflect.ownKeys(test).map((val, index)=>{
        //     console.log(val);
            
        // });

    </script>
</body>
</html>