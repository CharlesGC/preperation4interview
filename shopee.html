<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // ----↓---------------------↓------------------↓------------------↓--------------------------↓---------------------------
      // symmetric(lastRight对称点) j(i对称点)     lastMiddle              i                       lastRight
      // lastRight<=i, =>没有计算过点数据可以复用，乖乖从半径1开始一个一个计算是否对称
      // lastRight>i 分两种情况，但是 j= 2*lastMiddle-i
      // 1. lastRight-i > radiusArr[j] => radiusArr[j]回文已经对比过，lastMiddle是[j,i]和[symmetric, lastRight]中点，所以radiusArr[i]的最小初始半径应该是radiusArr[j]
      // 2. lastRight-i <= radiusArr[j] => lastRight-i回文已经对比过，lastMiddle是[j,i]和[symmetric, lastRight]中点，，所以radiusArr[i]的最小初始半径应该是lastRight-i
      // 综上所述， radiusArr[i] = lastRight>i ? Math.min(radiusArr[2*lastMiddle-i],lastRight-i) : 1

      // 使用拉马车算法，Manacher算法，马拉车算法
      function longestpalindrome(str) {
        let formatStr = "$#" + str.split("").join("#") + "#";
        let radiusArr = Array.from({ length: formatStr.length }, () => {
          return 0;
        });

        // console.log(formatStr,radiusArr);

        //lastMiddle为上一个中心点的位置，lastRight为上一个最右端的点的位置
        let lastMiddle = 0,
          lastRight = 0;
        //maxRadius为最大回文串的半径，maxMiddle为最大回文字符中心点的位置
        let maxRadius = 0,
          maxMiddle = 0;
        // 从第二个字符开始以i作为移动的中心点的位置
        for (let i = 1; i < formatStr.length; ++i) {
          // lastRight<=i, =>没有计算过点数据可以复用，乖乖从半径1开始一个一个计算是否对称
          // lastRight>i 分两种情况，但是 j= 2*lastMiddle-i
          // 1. lastRight-i > radiusArr[j] => radiusArr[j]回文已经对比过，lastMiddle是[j,i]和[symmetric, lastRight]中点，所以radiusArr[i]的最小初始半径应该是radiusArr[j]
          // 2. lastRight-i <= radiusArr[j] => lastRight-i回文已经对比过，lastMiddle是[j,i]和[symmetric, lastRight]中点，，所以radiusArr[i]的最小初始半径应该是lastRight-i
          // 综上所述， radiusArr[i] = lastRight>i ? Math.min(radiusArr[2*lastMiddle-i],lastRight-i) : 1
          radiusArr[i] =
            lastRight > i
              ? Math.min(radiusArr[2 * lastMiddle - i], lastRight - i)
              : 1;
          // i是移动的中心点，p中存储的是以索引i为中心点的半径数组，只要对称则半径加1
          while (formatStr[i + radiusArr[i]] === formatStr[i - radiusArr[i]])
            ++radiusArr[i];
          // 输出所有的对称回文子串
          let tempSub = str.substr((i - radiusArr[i]) / 2, radiusArr[i] - 1);
          console.log(tempSub ? tempSub : "empty");
          if (lastRight < i + radiusArr[i]) {
            lastRight = i + radiusArr[i];
            lastMiddle = i;
          }
          if (maxRadius < radiusArr[i]) {
            maxRadius = radiusArr[i];
            maxMiddle = i;
          }
        }

        // console.log(formatStr.substring((maxMiddle-maxRadius+1), (maxMiddle+maxRadius-1)));
        // 开始位置：索引从零开始加了$符抵消了，所以不用-1了（中点-半径除于2即可），截取长度等于半径-1，因为半径都是加过1的。
        return str.substr((maxMiddle - maxRadius) / 2, maxRadius - 1);
      }

      // console.log(longestpalindrome("a"));
      // console.log(longestpalindrome("aab"));
      // console.log(longestpalindrome("abcde"));
      // console.log(longestpalindrome("zzbaabcd"));
      // console.log(longestpalindrome(""));
      // console.log(longestpalindrome("abbaz"));
      // console.log(longestpalindrome("i like racecars that go fast"));
      // console.log(longestpalindrome("i am baab mbcd"));

      // let fn = (a,b)=>{
      //     return a+b;
      // }
      // let res = fn.call(1,2);
      // res;

      let p1 = () => {
        return new Promise((resolve, reject) => {
          setTimeout(function () {
            console.log("p1");
            resolve();
          }, 2000);
        });
      };

      let p2 = () => {
        return new Promise((resolve, reject) => {
          setTimeout(function () {
            console.log("p2");
            resolve();
          }, 2000);
        });
      };

      // let p3= new Promise((resolve,reject)=>{
      //         setTimeout(function(){
      //             console.log("p3");
      //             resolve();
      //         },2000);
      //     });
      //     let p4= new Promise((resolve,reject)=>{
      //         setTimeout(function(){
      //             console.log("p4");
      //             resolve();
      //         },2000);
      //     });

      //  异步promise同步按顺序执行
      // function runPromiseByQueue(myPromises) {
      //     myPromises.reduce(
      //         (previousPromise, nextPromise) => previousPromise.then(() => nextPromise()),
      //         Promise.resolve()
      //     );
      // }

      // const createPromise = (time, id) => () =>
      //     new Promise(solve =>
      //         setTimeout(() => {
      //         console.log("promise", id);
      //         solve();
      //         }, time)
      //     );

      // runPromiseByQueue([
      //     createPromise(3000, 1),
      //     createPromise(2000, 2),
      //     createPromise(1000, 3)
      // ]);
      // runPromiseByQueue([p1, p2]);

      // [p1, p2].reduce((total, currentVal)=>{
      //     total.then(currentVal);
      // });

      class test {
        constructor(name) {
          // this.name = name;
        }
        static sMethod() {
          console.log("smethod");
        }
        sayName() {
          console.log(this.name);
        }
      }

      // for (const key in test) {
      //     if (test.hasOwnProperty(key)) {
      //         const element = test[key];
      //         console.log(element);
      //     }
      // }
      // console.log("-----")
      // // 不可枚举属性也可以遍历出来
      // Reflect.ownKeys(test).map((val, index)=>{
      //     console.log(val);

      // });

      /*
          给两个版本号 a 和 b ，用逗号和一个空格分隔开，判断大小。假设两个版本的版本段是一致的.

          a<b 输出 -1
          a=b 输出 0
          a>b 输出 1
          样例输入
          1.10.2, 1.2.10
          样例输出
          1
        */
      function compareVersion(str) {
        const versions = str.split(", ");
        const [v1, v2] = versions;
        function getAllVersion(version) {
          return version.split(".");
        }
        const v1Versions = getAllVersion(v1);
        const v2Versions = getAllVersion(v2);
        // 两个版本段一致，所有数组长度相等
        for (let index = 0; index < v1Versions.length; index++) {
          const v1Version = v1Versions[index];
          const v2Version = v2Versions[index];
          if (v1Version > v2Version) {
            return 1;
          } else if (v2Version < v1Version) {
            return -1;
          }
        }
        return 0;
      }
      console.log(compareVersion("1.10.2, 1.2.10"));

      /*
          输入一个有序 int 数组，去重规则：数字 x 的出现次数不超过 x，问去重后数组的最大长度
          样例输入
          1 1 1 2 2 2 3 3 3
          样例输出
          6
        */
      function getRepeatArrMaxLen(arr) {
        let len = 0;
        let maxLen = 0;
        let lastNum;
        for (let index = 0; index < arr.length; index++) {
          const currentNum = arr[index];
          if (lastNum === currentNum) {
            if (++len < currentNum) {
              maxLen++;
            }
          } else {
            len = 0;
            lastNum = currentNum;
            maxLen++;
          }
        }
        return maxLen;
      }

      console.log(getRepeatArrMaxLen([1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4]));

      /*
          经典动态规划题，给定 m 和 n 表示矩阵的长宽，小明从左上角走到右下角一共有多少条路，只等向右走或者向下走。注意数字溢出问题。 m n 的值都不超过 50.
          样例输入
          3 2
          样例输出
          3
        */
      // function getWays(m,n){
      //   if(m===1 || n===1){
      //     // 终止条件
      //     return 1;
      //   } else{
      //     // 子方程
      //     return getWays(m-1,n)+getWays(m,n-1);
      //   }
      // }
      function getWays(m, n) {
        let matrix = [];
        let line = Array.from({ length: n }, (val, index) => 1);

        for (let col = 0; col < m; col++) {
          matrix.push(line);
        }

        for (let i = 1; i < m; i++) {
          for (let j = 1; j < n; j++) {
            matrix[i][j] = matrix[i - 1][j] + matrix[i][j - 1];
          }
        }
        return matrix[m - 1][n - 1];
      }

      console.log(getWays(3, 2));

      /*
          给定一个数组，求数组中比当前元素小的个数
          比如[8,1,2,2,3]->[4, 0, 1, 1, 3]
          最简单的办法是使用两层循环暴力破解，事件复杂度是n^2
          第二种方式是使用二分搜索树，加一个smaller变量来标记比当前小的所有节点个数
        */
      // function countSmaller(arr){
      //   let res = [];
      //   let len = arr.length;
      //   let i=0,j=0;
      //   while (i<len) {
      //     let currentNum = arr[i];
      //     let count=0;
      //     for (let j = 0; j < arr.length; j++) {
      //       if(j===i){
      //         continue;
      //       } else{
      //         let num = arr[j];
      //         if(num<currentNum){
      //           count++;
      //         }
      //       }
      //     }
      //     res.push(count);
      //     i++;
      //   }
      //   return res;
      // }

      /*
          第二种方式是使用二分搜索树，加一个smaller变量来标记比当前小的所有节点个数
        */
      // function BinarySearchTree(){
      //   function Node(key){
      //     this.key = key;
      //     this.smaller = 0;
      //     this.left = null;
      //     this.right = null;
      //   }
      //   let root = null;

      //   function insertNode(node, newNode){
      //     if(node.key>newNode.key){
      //       if(node.left===null){
      //         node.left = newNode;
      //       } else{
      //         insertNode(node.left, newNode);
      //       }
      //     } else{
      //       if(node.right === null){
      //         node.right = newNode;
      //       } else {
      //         insertNode(node.right, newNode);
      //       }
      //     }
      //   }

      //   this.insert=function(key){
      //     let newNode = new Node(key);
      //     if(root === null){
      //       root = newNode;
      //     } else {
      //       insertNode(root, newNode);
      //     }
      //     return root;
      //   }
      // }

      function countSmaller(arr) {
        function Node(key) {
          this.key = key;
          this.smaller = 0;
          this.left = null;
          this.right = null;
        }

        let root = null;
        let nodes = [];

        let insertNode = function (node, newNode) {
          // 小的在左侧子树
          if (node.key >= newNode.key) {
            if (node.key > newNode.key) {
              // 只有父节点比子节点大的时候，父节点才需要+1
              node.smaller++;
            }
            if (node.left === null) {
              node.left = newNode;
            } else {
              insertNode(node.left, newNode);
            }
          } else {
            // 大的放在右侧子树， 因为当前节点大，所以比当前节点小的数是父节点smaller+1
            newNode.smaller = node.smaller + 1;
            if (node.right === null) {
              node.right = newNode;
            } else {
              insertNode(node.right, newNode);
            }
          }
        };

        let insert = function (key) {
          let newNode = new Node(key);
          if (root === null) {
            root = newNode;
          } else {
            insertNode(root, newNode);
          }
          return newNode;
        };

        for (let i = arr.length - 1; i >= 0; i--) {
          const key = arr[i];
          nodes[i] = insert(key);
        }
        return nodes.map((node) => node.smaller);
      }

      console.log(countSmaller([8, 1, 2, 2, 3]));
      console.log(countSmaller([5, 2, 6, 1]));
      console.log(countSmaller([8, 5, 7, 2, 3]));

      /* 
          将字符串中小写字母移到前面，大写字母移到后面，并保证顺序不变
        */
      function reSortStr(str) {
        let lower = [],
          upper = [];
        for (let index = 0; index < str.length; index++) {
          const char = str[index];
          if (/[a-z]/.test(char)) lower.push(char);
          if (/[A-Z]/.test(char)) upper.push(char);
        }
        return lower.concat(...upper).join("");
      }
      console.log(reSortStr("abCDefGhI"))
    </script>
  </body>
</html>
