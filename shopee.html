<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        // ----↓---------------------↓------------------↓------------------↓--------------------------↓---------------------------
        // symmetric(lastRight对称点) j(i对称点)     lastMiddle              i                       lastRight
        // lastRight<=i, =>没有计算过点数据可以复用，乖乖从半径1开始一个一个计算是否对称
        // lastRight>i 分两种情况，但是 j= 2*lastMiddle-i
        // 1. lastRight-i > radiusArr[j] => 说明radiusArr[j]肯定回文对比过，但lastRight-radiusArr[j]是没有做过回文对比的，所以radiusArr[i]的初始半径应该是radiusArr[j]
        // 2. lastRight-i <= radiusArr[j] => 说明lastRight-i肯定已经回文对比过，再大的半径就不确定了，所以radiusArr[i]的初始半径应该是lastRight-i
        // 综上所述， radiusArr[i] = lastRight>i ? Math.min(radiusArr[2*lastMiddle-i],lastRight-i) : 1

        // 使用拉马车算法，Manacher算法，马拉车算法
        function longestpalindrome(str){

            let formatStr = "$#" + str.split("").join("#")+"#";
            let radiusArr = Array.from({length: formatStr.length},()=>{return 0;});

            // console.log(formatStr,radiusArr);

            //lastMiddle为上一个中心点的位置，lastRight为上一个最右端的点的位置
            let lastMiddle=0,lastRight=0 
            //maxRadius为最大回文串的半径，maxMiddle为最大回文字符中心点的位置
            let maxRadius=0, maxMiddle=0;    
            // 从第二个字符开始以i作为移动的中心点的位置
            for (let i = 1; i < formatStr.length; ++i) {
              // lastRight<=i, =>没有计算过点数据可以复用，乖乖从半径1开始一个一个计算是否对称
              // lastRight>i 分两种情况，但是 j= 2*lastMiddle-i
              // 1. lastRight-i > radiusArr[j] => 说明radiusArr[j]肯定回文对比过，但lastRight-radiusArr[j]是没有做过回文对比的，所以radiusArr[i]的初始半径应该是radiusArr[j]
              // 2. lastRight-i <= radiusArr[j] => 说明lastRight-i肯定已经回文对比过，再大的半径就不确定了，所以radiusArr[i]的初始半径应该是lastRight-i
              // 综上所述， radiusArr[i] = lastRight>i ? Math.min(radiusArr[2*lastMiddle-i],lastRight-i) : 1
              radiusArr[i] = lastRight > i ? Math.min(radiusArr[2 * lastMiddle - i], lastRight - i) : 1;
              // i是移动的中心点，p中存储的是以索引i为中心点的半径数组，只要对称则半径加1
              while (formatStr[i + radiusArr[i]] === formatStr[i - radiusArr[i]]) ++radiusArr[i]; 
              if (lastRight < i + radiusArr[i]) {
                  lastRight = i + radiusArr[i];
                  lastMiddle = i;
              }
              if (maxRadius < radiusArr[i]) {
                  maxRadius = radiusArr[i];
                  maxMiddle = i;
              }
            }

            // console.log(formatStr.substring((maxMiddle-maxRadius+1), (maxMiddle+maxRadius-1)));
            // 开始位置：索引从零开始加了$符抵消了，所以不用-1了（中点-半径除于2即可），截取长度等于半径-1，因为半径都是加过1的。
            return str.substr(((maxMiddle - maxRadius) / 2), maxRadius-1);
        }

        console.log(longestpalindrome("a"));
        console.log(longestpalindrome("aab"));
        console.log(longestpalindrome("abcde"));
        console.log(longestpalindrome("zzbaabcd"));
        console.log(longestpalindrome(""));
        console.log(longestpalindrome("abbaz"));
        console.log(longestpalindrome("i like racecars that go fast"));
        console.log(longestpalindrome("i am baab mbcd"));

        // let fn = (a,b)=>{
        //     return a+b;
        // }
        // let res = fn.call(1,2);
        // res;

        let p1 = ()=>{
            return new Promise((resolve,reject)=>{
                setTimeout(function(){
                    console.log("p1");     
                    resolve();           
                },2000);
            });
        };

        let p2 = ()=>{
            return new Promise((resolve,reject)=>{
                setTimeout(function(){
                    console.log("p2");     
                    resolve();           
                },2000);
            });
        };
        
        // let p3= new Promise((resolve,reject)=>{
        //         setTimeout(function(){
        //             console.log("p3");     
        //             resolve();           
        //         },2000);
        //     });
        //     let p4= new Promise((resolve,reject)=>{
        //         setTimeout(function(){
        //             console.log("p4");     
        //             resolve();           
        //         },2000);
        //     });


        // function runPromiseByQueue(myPromises) {
        //     myPromises.reduce(
        //         (previousPromise, nextPromise) => previousPromise.then(() => nextPromise()),
        //         Promise.resolve()
        //     );
        // }

        // const createPromise = (time, id) => () =>
        //     new Promise(solve =>
        //         setTimeout(() => {
        //         console.log("promise", id);
        //         solve();
        //         }, time)
        //     );

        // runPromiseByQueue([
        //     createPromise(3000, 1),
        //     createPromise(2000, 2),
        //     createPromise(1000, 3)
        // ]);
        // runPromiseByQueue([p1, p2]);
        
        // [p1, p2].reduce((total, currentVal)=>{
        //     total.then(currentVal);
        // });

        class test{
            constructor(name){
                // this.name = name;
            }
            static sMethod(){
                console.log("smethod");
                
            }
            sayName(){
                console.log(this.name);                
            }
        }

        // for (const key in test) {
        //     if (test.hasOwnProperty(key)) {
        //         const element = test[key];
        //         console.log(element);
        //     }
        // }
        // console.log("-----")
        // // 不可枚举属性也可以遍历出来
        // Reflect.ownKeys(test).map((val, index)=>{
        //     console.log(val);
            
        // });

    </script>
</body>
</html>