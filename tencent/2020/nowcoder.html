<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
      单链表环的问题，可参考：https://www.cnblogs.com/dancingrain/p/3405197.html
      判断链表是否有环，这道题是快慢指针的经典应用。只需要设两个指针，
      一个每次走一步的慢指针和一个每次走两步的快指针，如果链表里有环的话，两个指针最终肯定会相遇
    */
      function hasCycle(head) {
        let slow = head,
          fast = head;
        while (fast != null && fast.next != null) {
          slow = slow.next;
          fast = fast.next.next;
          if (slow == fast) return true;
        }
        return false;
      }
      /*
      如果有环，求单链表中环的起始点
      首先还是使用快慢指针，两个指针相遇了后，让其中一个指针从链表头开始，当然此时两个指针速度一样都是一步一步走，
      此时再相遇的位置就是链表中环的起始位置，原理如下
      快指针是慢指针速度的两倍，而快指针又比慢指针多走一圈，所以当它们第一次相遇时，head到入口的距离+入口到相遇点的距离
      等于环一圈的距离，那么第二次以相同速度一步一步走再次相遇肯定在起点
    */
      function detectCycleEntry(head) {
        let slow = head,
          fast = head;
        while (fast && fast.next) {
          slow = slow.next;
          fast = fast.next.next;
          if (slow === fast) break;
        }
        if (!fast || !fast.next) return NULL; //没有环，返回NULL值
        slow = head; // 慢指针从头开始走
        while (slow != fast) {
          // 此时快慢指针都是一步一步走
          slow = slow.next;
          fast = fast.next;
        }
        return fast;
      }
      /*
      如果有环，求单链表中环的节点个数，当第一次相遇之后，慢节点接着走，再次相遇所走的步数就是环数
    */
      function detectCycleLength(head) {
        let slow = head,
          fast = head;
        while (fast && fast.next) {
          slow = slow.next;
          fast = fast.next.next;
          if (slow === fast) break;
        }
        if (!fast || !fast.next) return NULL; //没有环，返回NULL值
        let count = 0;
        while (slow != fast) {
          slow = slow.next;
          count++;
        }
        return count;
      }

      /*
        求整个链的长度，head到入口的距离+环长
      */
      function linkedLength(head) {
        let slow = head,
          fast = head;
        let head2EntryCount=0;
        while (fast && fast.next) {
          slow = slow.next;
          fast = fast.next.next;
          head2EntryCount++;
          if (slow === fast) break;
        }
        if (!fast){
          //没有环，返回NULL值, fast为空则为2的倍数
          return 2*head2EntryCount;
        }
        if(!fast.next){
          //没有环，返回NULL值, fast为空则为2的倍数
          return 2*head2EntryCount +1;
        }
        // 环的个数
        let count = 0;
        while (slow != fast) {
          slow = slow.next;
          count++;
        }
        // 链表长度等于
        return head2EntryCount+count;
      }

      /*
        判断两个无环链表是否相交，以及第一个交点，
        首先让其中一个链表的tail.next=head形成一个环
        然后就回到hasCycle，detectCycleEntry
      */

    </script>
  </body>
</html>
